/*
Created by Franz Zemen 12/10/2022
License Type: MIT
*/

import {ContainsDirectories, Directories, Directory, DirectoryPath} from '../../../options/directories.js';
import {Pipeline} from '../../../pipeline/pipeline.js';
import {TransformInOut} from '../../transform-in-out.js';
import {TransformConstructor} from '../../transform.js';
import {CreateProjectDirectory} from './create-project-directory.transform.js';
import {CreateRootDirectory} from './create-root-directory.transform.js';


export class CreateDirectories extends TransformInOut<ContainsDirectories, Directory> {
  constructor(logDepth: number) {
    super(logDepth);
  }

  executeImpl(passedIn: ContainsDirectories): Promise<Directory> {
    if (passedIn) {
      const directories: Directories = passedIn.directories;
      const passIns: Directory[] = [];
      let createProjectDirectories: TransformConstructor<any>[] = []
      let key: DirectoryPath | 'root';
      for(key in directories) {
        if(key == 'root') continue;
        if(!directories[key].autogenerated) {
          passIns.push(directories[key]);
          createProjectDirectories.push(CreateProjectDirectory);
        }
      }

      return Pipeline
        .options<Directory, void>({name: 'create directories', logDepth: this.depth + 1})
        .transform<CreateRootDirectory, undefined, Directory, Directory>(CreateRootDirectory)
        .parallels<Directory, void>(createProjectDirectories, ['void'], passIns as any [])
        .execute( directories.root)
        .then(() => passedIn.directories.root);
    } else {
      throw new Error('Undefined payload');
    }
  }

  public transformContext(payload: ContainsDirectories): string {
    return '';
  }

}

/*
const directories: Directories = payload.directories;
try {
  if(directories.root.directoryPath === 'NOT_DEFINED') {
    const msg = 'Undefined root folder';
    this.log.info(msg, 'error');
    this.errorCondition = true;
    return Promise.reject(new Error(msg));
  }
  if (existsSync(directories.root.directoryPath)) {
    const msg = `Project folder ${directories.root.directoryPath} already exists, not creating`;
    this.log.info(msg, 'error');
    this.errorCondition = true;
    return Promise.reject(new Error(msg));
  }
  const result = mkdirSync(directories.root.directoryPath, {recursive: true});
} catch (err) {
  const error = processUnknownError(err);
  this.log.error(error);
  return Promise.reject(error);
}
const paths: string[] = [];
const promises: Promise<undefined | string>[] = [];
for (let key of Object.keys(directories)) {
  let pathKey: DirectoryPath | 'root' = key as (DirectoryPath | 'root');
  if (pathKey !== 'root') {
    const dir = directories[pathKey];
    if (isDirectory(dir)) {
      const path = join(directories.root.directoryPath, dir.directoryPath);
      paths.push(path)
      promises.push(mkdir(path, {recursive: true}));
    }
  }
}
// We can launch these in parallel since they are independent transforms under root.
return Promise.allSettled(promises)
  .then((results) => {
    const failed: string[] = [];
    results.forEach((result, ndx) => {
      if (result.status === 'rejected') {
        failed.push(`Failed to create ${paths[ndx]}: ${result.reason}`);
      }
    })
    if (failed.length > 0) {
      this.log.warn(`Failed to create: ${inspect(failed, false, 10, true)}`);
      return Promise.reject(new Error(`Failed to create: ${inspect(failed, false, 10, true)}`));
    } else {
      return payload;
    }
  });


}


}

*/
