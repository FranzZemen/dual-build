/*
Created by Franz Zemen 12/10/2022
License Type: MIT
*/

import {ContainsDirectories, Directories, DirectoryPath} from '../../../options/directories.js';
import {Pipeline} from '../../../pipeline/pipeline.js';
import {Action} from '../../action.js';
import {CreateProjectDirectory, CreateProjectDirectoryPayload} from './create-project-directory.js';
import {CreateRootDirectory} from './create-root-directory.task.js';


export class CreateDirectories extends Action<ContainsDirectories, ContainsDirectories, void> {
  constructor(logDepth: number) {
    super(logDepth);
  }

  executeImpl(payload: ContainsDirectories): Promise<void> {
    if (payload) {
      const directories: Directories = payload.directories;
      const payloadOverrides: CreateProjectDirectoryPayload[] = [];
      let key: DirectoryPath | 'root';
      for(key in directories) {
        if(!directories[key].autogenerated) {
          payloadOverrides.push({root: directories['root'], directory: directories[key]});
        }
      }

      return Pipeline
        .options({name: 'Create Directories', logDepth: this.depth + 1})
        .action<CreateRootDirectory, Directories>(CreateRootDirectory, directories)
        .actions(CreateProjectDirectory, payloadOverrides)
        .execute(undefined);
    } else {
      throw new Error('Undefined payload');
    }
  }

  public actionContext(payload: ContainsDirectories): string {
    return '';
  }

}

/*
const directories: Directories = payload.directories;
try {
  if(directories.root.directoryPath === 'NOT_DEFINED') {
    const msg = 'Undefined root folder';
    this.log.info(msg, 'error');
    this.errorCondition = true;
    return Promise.reject(new Error(msg));
  }
  if (existsSync(directories.root.directoryPath)) {
    const msg = `Project folder ${directories.root.directoryPath} already exists, not creating`;
    this.log.info(msg, 'error');
    this.errorCondition = true;
    return Promise.reject(new Error(msg));
  }
  const result = mkdirSync(directories.root.directoryPath, {recursive: true});
} catch (err) {
  const error = processUnknownError(err);
  this.log.error(error);
  return Promise.reject(error);
}
const paths: string[] = [];
const promises: Promise<undefined | string>[] = [];
for (let key of Object.keys(directories)) {
  let pathKey: DirectoryPath | 'root' = key as (DirectoryPath | 'root');
  if (pathKey !== 'root') {
    const dir = directories[pathKey];
    if (isDirectory(dir)) {
      const path = join(directories.root.directoryPath, dir.directoryPath);
      paths.push(path)
      promises.push(mkdir(path, {recursive: true}));
    }
  }
}
// We can launch these in parallel since they are independent actions under root.
return Promise.allSettled(promises)
  .then((results) => {
    const failed: string[] = [];
    results.forEach((result, ndx) => {
      if (result.status === 'rejected') {
        failed.push(`Failed to create ${paths[ndx]}: ${result.reason}`);
      }
    })
    if (failed.length > 0) {
      this.log.warn(`Failed to create: ${inspect(failed, false, 10, true)}`);
      return Promise.reject(new Error(`Failed to create: ${inspect(failed, false, 10, true)}`));
    } else {
      return payload;
    }
  });


}


}

*/
